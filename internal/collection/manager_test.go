package collection

import (
	"testing"

	"github.com/polyse/database/pkg/filters"

	"github.com/polyse/database/test/mocks"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
)

func TestSimpleProcessor_GetCollectionName(t *testing.T) {
	type fields struct {
		filters []filters.Filter
		repo    Repository
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		{
			name: "Normal Test",
			fields: fields{
				repo: NewNutRepo("testCollection", nil),
			},
			want: "testCollection",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &SimpleProcessor{
				filters: tt.fields.filters,
				repo:    tt.fields.repo,
			}
			if got := p.GetCollectionName(); got != tt.want {
				t.Errorf("GetCollectionName() = %v, want %v", got, tt.want)
			}
		})
	}
}

type processorTestSuite struct {
	suite.Suite
	pr Processor
	tr *MockRepository
}

func TestStartProcessorSuit(t *testing.T) {
	suite.Run(t, new(processorTestSuite))
}

func (pts *processorTestSuite) SetupTest() {
	testRepo := new(MockRepository)

	testRepo.
		On("GetCollectionName").
		Return("testCollection").
		On("Save", mock.Anything).
		Return(nil)

	pts.pr = NewSimpleProcessor(testRepo, filters.FilterText, filters.StemmAndToLower, filters.StopWords)
	pts.tr = testRepo
}

func (pts *processorTestSuite) TestSimpleProcessor_ProcessAndInsertString() {
	assert.NoError(pts.T(), pts.pr.ProcessAndInsertString(map[string]string{"test": "is Data map"}))
	pts.tr.AssertCalled(pts.T(), "Save",
		map[string][]ByteArr{
			"data": {&Index{"test", []int{0}}},
			"map":  {&Index{"test", []int{1}}},
		},
	)
}

type processorManagerTestSuite struct {
	suite.Suite
	prm *SimpleProcessorManager
	tr  *mocks.Processor
	tr2 *mocks.Processor
}

func TestStartProcessorManagerSuit(t *testing.T) {
	suite.Run(t, new(processorManagerTestSuite))
}

func (pts *processorManagerTestSuite) SetupTest() {
	testProc := new(mocks.Processor)

	testProc.
		On("ProcessAndInsertString", mock.Anything, mock.Anything).
		Return(nil).
		On("GetCollectionName").
		Return("testCollection")

	testProc2 := new(mocks.Processor)
	testProc2.
		On("ProcessAndInsertString", mock.Anything, mock.Anything).
		Return(nil).
		On("GetCollectionName").
		Return("secondTestCollection")

	pts.prm = NewSimpleProcessorManagerWithProc(testProc)

	pts.prm.AddProcessor(testProc2)
	pts.tr = testProc
	pts.tr2 = testProc2
}

func (pts *processorManagerTestSuite) TestSimpleProcessorManager_AddProcessors() {
	pts.Len(pts.prm.processors, 2)
	pts.prm.AddProcessor(
		NewSimpleProcessor(
			NewNutRepo("testCollection3", nil),
			filters.FilterText,
			filters.StemmAndToLower,
			filters.StopWords,
		),
	)
	pts.Len(pts.prm.processors, 3)
}

func (pts *processorManagerTestSuite) TestSimpleProcessorManager_ProcessAndInsertString() {
	assert.NoError(pts.T(), pts.prm.ProcessAndInsertString(map[string]string{"test": "data"}, "testCollection"))
	pts.tr.AssertCalled(pts.T(), "ProcessAndInsertString", map[string]string{"test": "data"})
	pts.tr2.AssertNotCalled(pts.T(), "ProcessAndInsertString", mock.Anything, mock.Anything)
}

// Repository is an autogenerated mock type for the Repository type
type MockRepository struct {
	mock.Mock
}

// GetCollectionName provides a mock function with given fields:
func (_m *MockRepository) GetCollectionName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Save provides a mock function with given fields: ent
func (_m *MockRepository) Save(ent map[string][]ByteArr) error {
	ret := _m.Called(ent)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string][]ByteArr) error); ok {
		r0 = rf(ent)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
